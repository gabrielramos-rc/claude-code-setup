# Framework v0.3 Realistic Roadmap

**Created:** 2025-12-06
**Status:** Ready for Implementation
**Source:** Consolidated analysis of 25 considerations + Claude official documentation research

---

## Executive Summary

After critical analysis of all 25 considerations and research into Claude official documentation, we've identified **6 realistic, high-impact solutions** that address the core problems within our actual capabilities.

### What We Actually Control

**We CAN control:**
- ‚úÖ Markdown files in `.claude/` directory
- ‚úÖ Agent prompts and instructions
- ‚úÖ Command orchestration (which agents, what order, parallel execution)
- ‚úÖ Context passed to agents via command prompts
- ‚úÖ CLAUDE.md rules and guidelines

**We CANNOT control:**
- ‚ùå How Read/Write/Edit/Bash tools work internally
- ‚ùå Whether agents follow instructions (only suggest/guide)
- ‚ùå Claude Code session metadata exports
- ‚ùå How Claude Code discovers slash commands
- ‚ùå Tool-level caching mechanisms

### Impact Summary

**Token Efficiency (40-50% reduction possible):**
- Command-level context injection: 20-30% reduction
- File tree context: 10-15% reduction
- Document ordering optimization: 30% performance boost (official research)

**Quality Coverage:**
- 0 ‚Üí 100% Testing agent coverage
- 0 ‚Üí 100% Security auditor for auth/data phases
- Parallel execution: Minutes ‚Üí Seconds validation time

**User Experience:**
- Resume capability after quota limits
- Automated git workflow (distributed, not centralized)
- CLAUDE.md auto-population

---

## Research Findings from Claude Official Documentation

### Key Insights Applied to Our Framework

**1. Multi-Agent Orchestration** (Source: [Subagents in SDK](https://platform.claude.com/docs/en/agent-sdk/subagents.md))

> "Multiple subagents can run **concurrently**, dramatically reducing review time. Running style-checker, security-scanner, and test-coverage subagents simultaneously reduces multi-minute reviews to seconds."

**Impact on our design:** Commands should invoke Tester + Security + Reviewer in PARALLEL, not serial.

**2. Context Window Optimization** (Source: [Long Context Tips](https://platform.claude.com/docs/en/build-with-claude/prompt-engineering/long-context-tips.md))

> "Place long documents (20K+ tokens) **near the top** of prompts... This significantly improves performance across all models."

**Impact on our design:** Load specs at TOP of agent prompts using structured XML format.

**3. Tool Specialization** (Source: [Subagents](https://platform.claude.com/docs/en/agent-sdk/subagents.md))

> "Subagents can be limited to specific tools, reducing unintended action risk. Example: a doc-reviewer subagent with only Read and Grep tools ensures analysis without accidental modifications."

**Impact on our design:** Don't restrict tools, but define clear USAGE GUIDELINES for what each agent should/shouldn't do with each tool.

**4. Structured Document Metadata**

Use XML tags for clarity:
```xml
<documents>
  <document index="1">
    <source>architecture.md</source>
    <document_content>{{ARCHITECTURE}}</document_content>
  </document>
</documents>
```

**Impact on our design:** Commands should structure specs in XML when injecting into agent prompts.

**5. Strict Agent Specialization**

> "Each agent owns one domain, preventing coordination overhead... Specialization enables concurrent execution."

**Impact on our design:** Strict roles with clear file boundaries, but with usage guidelines not tool restrictions.

---

## Issue Consolidation: From 25 to 6 Real Solutions

### Issues We CAN Fix (17 issues ‚Üí 6 solutions)

#### Root Cause 1: Agents Lack Context
**Issues:** CON-10 (partial), CON-16, CON-17, CON-11
**Pattern:** Agents read/explore because they don't have context upfront
**Solution:** **#1 - Command-Level Context Injection**

#### Root Cause 2: Commands Don't Invoke Quality Agents
**Issues:** CON-18, CON-19, CON-20, CON-24, CON-25
**Pattern:** We have quality agents but don't invoke them
**Solution:** **#2 - Quality Agent Orchestration with Parallelization**

#### Root Cause 3: No Session Persistence
**Issues:** CON-06, CON-09, CON-01
**Pattern:** No state persists across interruptions
**Solution:** **#3 - State-Based Session Management**

#### Root Cause 4: No Distributed Git Workflow
**Issues:** CON-07, CON-03
**Pattern:** Manual git operations, no automation
**Solution:** **#4 - Distributed Git Workflow**

#### Root Cause 5: Organizational Inconsistency
**Issues:** CON-04, CON-08
**Pattern:** No standards for file organization
**Solution:** **#5 - Documentation & Standards**

#### Root Cause 6: No Role Enforcement
**Issues:** CON-11 (Architect creating code), Engineer-heavy workflow
**Pattern:** Agents overstep boundaries (write code outside their domain)
**Solution:** **#6 - Role Enforcement Through Usage Guidelines**

### Issues We CANNOT Fix (8 issues)

**Claude Code Infrastructure (outside our control):**
- **CON-02:** Slash commands auto-loading - Requires Claude Code changes
- **CON-05:** Agent time awareness - Claude's system prompt domain
- **CON-13, CON-14, CON-22:** Export metadata - Claude Code export format
- **CON-15, CON-21, CON-23:** Efficiency metrics - Observational only, no enforcement

**What we can do:** Document as Claude Code feature requests, implement partial workarounds (agents self-report to state files)

### Issues That Were Duplicates/Consequences

- **CON-10:** Token utilization - This is the SUM of CON-16 + CON-17, not separate
- **CON-12:** Agent file caching - Just moves the problem (read cache.md instead), focus on CON-17
- **CON-18:** Engineer-heavy - Consequence of not invoking quality agents (CON-19, 20, 24)
- **CON-25:** No quality gates - Same as CON-19, 20

---

## The 6 Realistic Solutions

## Solution #1: Command-Level Context Injection

### Problem It Solves

**CON-17 (CRITICAL):** 10 different agents each read architecture.md separately (28 redundant reads)
**CON-16 (HIGH):** Agents run 122 Bash commands for file discovery (60% are ls/find/grep)
**CON-11 (MEDIUM):** Architect creates code, Engineer deletes it, recreates later

**Root Cause:** Each agent explores independently because they lack context upfront.

### Solution

**Commands read context ONCE, inject into ALL agent prompts.**

#### Implementation

```markdown
# .claude/commands/implement.md

## Step 0: Load Context (Once Per Command)

Before invoking any agents, read:

1. Core specifications:
   - `.claude/specs/architecture.md`
   - `.claude/specs/tech-stack.md`
   - `.claude/specs/requirements.md`

2. Generate project file tree:
   ```bash
   tree -L 3 -I 'node_modules|.git' > /tmp/project-tree.txt
   ```

3. Create structured context document

## Step 1: Invoke Architect

Use Task tool with this prompt structure (IMPORTANT: specs at TOP per research):

```
<documents>
  <document index="1">
    <source>.claude/specs/requirements.md</source>
    <document_content>
    {{REQUIREMENTS_CONTENT}}
    </document_content>
  </document>

  <document index="2">
    <source>.claude/specs/tech-stack.md</source>
    <document_content>
    {{TECH_STACK_CONTENT}}
    </document_content>
  </document>

  <document index="3">
    <source>Project File Tree</source>
    <document_content>
    {{PROJECT_TREE}}
    </document_content>
  </document>
</documents>

You are the Architect agent.

**Context already loaded above - DO NOT re-read these files.**

Your task: Design Phase 2 authentication following the tech stack and requirements above.

Output to: .claude/specs/phase2-architecture.md
```

## Step 2: Invoke Engineer

Same pattern - inject context at TOP:

```
<documents>
  <document index="1">
    <source>.claude/specs/architecture.md</source>
    <document_content>{{ARCHITECTURE}}</document_content>
  </document>

  <document index="2">
    <source>.claude/specs/phase2-architecture.md</source>
    <document_content>{{PHASE2_ARCH}}</document_content>
  </document>

  <document index="3">
    <source>Project File Tree</source>
    <document_content>{{PROJECT_TREE}}</document_content>
  </document>
</documents>

You are the Engineer agent.

**Context already loaded above - DO NOT re-read these files.**

File tree shows you project structure - DO NOT run ls/find commands.

Your task: Implement Phase 2 authentication following the architecture specs above.
```
```

#### Why This Works

**Evidence:**
- Command reads specs: 1 time per spec
- 10 agents each receive context: 0 additional reads
- **Savings:** 28 redundant reads eliminated

**Research backing:**
> "Place long documents (20K+ tokens) near the top of prompts... This significantly improves performance across all models." - 30% performance boost

**File tree eliminates Bash discovery:**
- Agents see full project structure upfront
- No need for `ls`, `find`, `tree` commands
- **Savings:** ~70 Bash commands eliminated (60% of 122)

#### Expected Impact

- **20-30% token reduction** from eliminating redundant spec reads
- **10-15% token reduction** from eliminating Bash file discovery
- **30% performance improvement** from document ordering (research-backed)
- **Combined: 40-50% efficiency gain**

---

## Solution #2: Quality Agent Orchestration with Parallelization

### Problem It Solves

**CON-19 (CRITICAL):** 0 Testing agents in workflow - engineers test own code
**CON-20 (CRITICAL):** 0 Security auditor for Phase 2 authentication
**CON-24 (MEDIUM):** 0 Documentation agents - engineers write docs
**CON-18 (MEDIUM):** 8 Engineer agents, minimal validation

**Root Cause:** Commands don't invoke quality agents we already have.

### Solution

**Update commands to invoke quality agents with PARALLEL execution.**

#### Implementation

```markdown
# .claude/commands/implement.md

## Step 3: Implementation

Invoke Engineer agent with context (per Solution #1)

Engineer:
- Writes implementation code to src/*
- Documents work in `.claude/state/implementation-notes.md`
- Commits code to git

## Step 4: Quality Validation (PARALLEL EXECUTION)

**Research finding:** "Multiple subagents can run concurrently, dramatically reducing review time... reduces multi-minute reviews to seconds."

Read `.claude/state/implementation-notes.md` for context on what was implemented.

**Invoke these agents IN PARALLEL using Task tool:**

1. **Tester Agent**
   - Prompt: Design and run comprehensive tests for implementation
   - Context: implementation-notes.md + specs
   - Output: `.claude/state/test-results.md`

2. **Security Auditor Agent**
   - Prompt: Run security scans and audit implementation
   - Context: implementation-notes.md + specs
   - Output: `.claude/state/security-findings.md`

3. **Code Reviewer Agent**
   - Prompt: Review code quality, patterns, maintainability
   - Context: implementation-notes.md + specs
   - Output: `.claude/state/code-review-findings.md`

**Wait for ALL three agents to complete before proceeding.**

## Step 5: Check Results

Read all result files:
- `.claude/state/test-results.md` - Test coverage, pass/fail
- `.claude/state/security-findings.md` - CRITICAL/HIGH/MEDIUM/LOW findings
- `.claude/state/code-review-findings.md` - Quality issues

**Decision logic:**

If ANY critical issues found:
- Bounded reflexion: Invoke Engineer again (with findings as context)
- Update retry counter in `.claude/state/retry-counter.md`
- Max 3 retries per command, max 5 total across workflow
- If retries exhausted: Escalate to human

If all pass:
- Proceed to Step 6 (Documentation)

## Step 6: Documentation

Invoke Documenter agent:
- Update end-user documentation
- Generate API docs
- Update README if needed
- Output: `docs/*`

## Step 7: Human Gate (v0.2 pattern)

Present summary to user:
- What was implemented
- Test coverage: X%
- Security findings: 0 CRITICAL, Y HIGH, Z MEDIUM
- Code review: PASS/FAIL

Ask user: "Approve and continue? (y/n)"
```

#### Why This Works

**Parallelization impact:**
```
Serial (OLD):
Tester (5 min) ‚Üí Security (3 min) ‚Üí Reviewer (2 min) = 10 minutes

Parallel (NEW):
[Tester, Security, Reviewer] run concurrently = 5 minutes (longest agent)

Time savings: 50%
```

**Quality coverage:**
- Before: 0% dedicated testing/security/review
- After: 100% coverage with independent validation

**Research backing:**
> "Running style-checker, security-scanner, and test-coverage subagents simultaneously reduces multi-minute reviews to seconds."

#### Expected Impact

- **100% quality coverage** (Tester, Security, Reviewer for every implementation)
- **50% time reduction** through parallelization
- **Independent validation** (not engineers testing own code)
- **Bounded reflexion** prevents infinite loops while enabling auto-fixes

---

## Solution #3: State-Based Session Management

### Problem It Solves

**CON-06 (HIGH):** `.claude/plans/current-task.md` exists but unused - can't resume
**CON-09 (HIGH):** When hitting quota limit, unclear how to resume
**CON-01 (HIGH):** CLAUDE.md sections empty, unclear when to fill

**Root Cause:** No persistence of progress across interruptions.

### Solution

**Agents update state files with progress, resume command reads state.**

#### Implementation

##### 3.1: Task Tracking

```markdown
# Every command updates .claude/plans/current-task.md

## At Command Start

Write to `.claude/plans/current-task.md`:
```markdown
## Current Task
**Command:** /project:implement Phase 2
**Status:** IN_PROGRESS
**Started:** 2025-12-06 14:00:00
**Progress:** 0%

## Workflow Steps
- [ ] Architect: Design Phase 2
- [ ] Engineer: Implement Phase 2
- [ ] Validation: Test + Security + Review
- [ ] Documentation: Update docs
- [ ] Human gate: Approval

## Context
**Phase:** Phase 2 - Authentication
**Goal:** Implement JWT authentication with bcrypt password hashing
```

## During Execution (After Each Step)

Update progress:
```markdown
## Current Task
**Command:** /project:implement Phase 2
**Status:** IN_PROGRESS
**Started:** 2025-12-06 14:00:00
**Progress:** 60%

## Workflow Steps
- [x] Architect: Design Phase 2 ‚úì (completed 14:15)
- [x] Engineer: Implement Phase 2 ‚úì (completed 14:45)
- [x] Validation: Test + Security + Review ‚úì (completed 14:50)
- [ ] Documentation: Update docs ‚Üê CURRENT
- [ ] Human gate: Approval

## Last Checkpoint
**Completed:** Validation passed (tests: 85%, security: 0 critical, review: PASS)
**Next Step:** Invoke Documenter agent
**Files Modified:** src/auth/jwt.ts, src/middleware/auth.ts, tests/auth.test.ts

## Resume Instructions
If interrupted, run: `/project:resume`
```

## On Completion

```markdown
## Current Task
**Command:** /project:implement Phase 2
**Status:** COMPLETED
**Started:** 2025-12-06 14:00:00
**Completed:** 2025-12-06 15:10:00
**Duration:** 1h 10min

## Results
- Tests: 85% coverage, all passing
- Security: 0 critical findings
- Code review: PASS
- Documentation: Updated
```
```

##### 3.2: Resume Command

```markdown
# .claude/commands/resume.md
---
You are resuming a previously interrupted workflow.

## Step 1: Read State

Read `.claude/plans/current-task.md`

## Step 2: Present to User

Show user:
```
Last session was working on: {command}
Current phase: {phase}
Progress: {progress}%

Completed steps:
{completed_steps}

Last checkpoint: {last_completed_step}
Next step: {next_step}

Files modified: {files_list}
```

Ask: "Resume from here? (y/n)"

## Step 3: Resume Execution

If yes:
1. Load context from `.claude/specs/*` (Solution #1)
2. Read files listed in "Files Modified" to understand current state
3. Continue from "Next Step"
4. Update current-task.md as you progress

If no:
- Ask what they'd like to do instead
- Options: start fresh, modify task, abort
```

##### 3.3: CLAUDE.md Auto-Population

```markdown
# Update .claude/commands/start.md

## Step 4: Populate Project Documentation

After Architect creates specifications, invoke Architect again to populate CLAUDE.md:

**Architect Task:**
1. Read all specifications:
   - `.claude/specs/requirements.md`
   - `.claude/specs/architecture.md`
   - `.claude/specs/tech-stack.md`

2. Update `CLAUDE.md` sections:
   ```markdown
   ## Overview
   {1-2 paragraph summary from requirements.md}

   ## Technology Stack
   {formatted list from tech-stack.md}

   ## Project Structure
   {directory structure and architecture from architecture.md}

   ## Development Guidelines
   {key patterns and conventions from architecture.md}
   ```

3. Commit update:
   ```bash
   git add CLAUDE.md
   git commit -m "docs: auto-populate CLAUDE.md from specifications"
   ```
```

#### Why This Works

**Resume capability:**
- User hits quota limit ‚Üí session interrupted
- After quota resets ‚Üí `/project:resume`
- Command reads current-task.md ‚Üí shows progress ‚Üí continues from checkpoint
- No re-exploration needed (context in state files)

**CLAUDE.md synchronization:**
- Specs created ‚Üí CLAUDE.md updated automatically
- Always in sync with actual architecture
- No manual documentation lag

#### Expected Impact

- **Resume capability:** Seamless continuation after interruptions
- **Zero rework:** Don't start from scratch after quota limits
- **Automated docs:** CLAUDE.md always current
- **Progress visibility:** Users see exactly where workflow is

---

## Solution #4: Distributed Git Workflow

### Problem It Solves

**CON-07 (MEDIUM):** No systematic git commits, no remote pushes, can't rollback
**CON-03 (MEDIUM):** Manual metric tracking is error-prone

**Root Cause:** No automated git workflow, centralized to one agent.

### Solution

**Distributed git: Each agent commits their own work. DevOps coordinates strategy.**

#### Implementation

##### 4.1: Agent-Level Git Commits

```markdown
# Add to ALL agent prompts

## Git Workflow (Own Your Work)

After completing your responsibilities, commit your changes:

**For Architect:**
```bash
git add .claude/specs/
git commit -m "arch(phase-X): design for {feature}

- Architecture decisions in specs/architecture.md
- Technology selection in specs/tech-stack.md
- API contracts defined

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

**For Engineer:**
```bash
git add src/ tests/
git commit -m "feat(phase-X): implement {feature}

- Implementation in src/
- Tests in tests/
- Test coverage: X%

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

**For Tester:**
```bash
git add tests/
git commit -m "test(phase-X): comprehensive tests for {feature}

- Test coverage: X%
- All tests passing
- Edge cases covered

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

**For Documenter:**
```bash
git add docs/ README.md
git commit -m "docs(phase-X): update documentation for {feature}

- API documentation updated
- README updated
- Examples added

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

**Commit Message Convention:**
- feat: New feature
- fix: Bug fix
- test: Add/update tests
- docs: Documentation
- arch: Architecture/design
- refactor: Code refactor
- chore: Maintenance

**DO NOT push to remote** - DevOps agent handles this
```

##### 4.2: DevOps Coordination

```markdown
# .claude/agents/devops.md

## Git Strategy Coordination

You coordinate git workflow but don't write implementation code.

**Responsibilities:**

1. **Branch Management**
   - Create feature branches: `feature/phase-X-{feature-name}`
   - Create bugfix branches: `fix/{issue-name}`
   - Merge to main/dev when phase completes

2. **Release Management**
   - Tag releases: `v0.1.0`, `v0.2.0`
   - Generate changelogs from commit messages
   - Push tags to remote

3. **Remote Coordination**
   After phase completion:
   - Verify all agents committed their work
   - Ask user: "Push to remote? (y/n)"
   - If yes: `git push origin {branch-name}`

4. **Rollback Support**
   - If issues found, guide rollback:
   - `git revert {commit-hash}` for safe undo
   - Document rollback in `.claude/state/git-history.md`

**Tools:** Read, Write, Bash
```

##### 4.3: Automated Metrics Logging

```markdown
# Agents log to .claude/state/workflow-metrics.json

## After Each Command Execution

Append to workflow-metrics.json:
```json
{
  "session_id": "2025-12-06-implement-phase2",
  "command": "/project:implement",
  "phase": "Phase 2",
  "timestamp_start": "2025-12-06T14:00:00Z",
  "timestamp_end": "2025-12-06T15:10:00Z",
  "duration_minutes": 70,

  "agents_invoked": [
    {"role": "architect", "duration_min": 15},
    {"role": "engineer", "duration_min": 30},
    {"role": "tester", "duration_min": 10, "parallel": true},
    {"role": "security-auditor", "duration_min": 8, "parallel": true},
    {"role": "code-reviewer", "duration_min": 7, "parallel": true},
    {"role": "documenter", "duration_min": 10}
  ],

  "retries": 1,
  "retry_reason": "test_failure",

  "results": {
    "test_coverage": 85,
    "tests_passing": true,
    "security_critical": 0,
    "security_high": 2,
    "code_review": "PASS"
  },

  "git_commits": 5
}
```

## Post-Run Analysis

Read workflow-metrics.json and generate summary:
- Total time spent
- Agent utilization
- Retry patterns
- Quality metrics trends
```

#### Why This Works

**Distributed ownership:**
- Engineer commits code ‚Üí Tester commits tests ‚Üí Documenter commits docs
- Each agent owns their work end-to-end
- Natural workflow, not bottleneck

**Traceability:**
- Every change committed by the agent that made it
- Co-authored attribution shows framework usage
- Easy to see who did what

**Automated metrics:**
- Agents self-report to state files
- No manual counting
- Trends visible over time

#### Expected Impact

- **Systematic commits:** Every phase leaves git history
- **Distributed ownership:** No bottleneck, agents own their work
- **Automated tracking:** Metrics logged without manual effort
- **Rollback capability:** Can undo any phase safely

---

## Solution #5: Documentation & Standards

### Problem It Solves

**CON-04 (LOW):** "Open Questions" from PM with no tracking
**CON-08 (LOW):** Engineer created `PROJECT_INITIALIZATION_SUMMARY.md` in root - unclear if standard

**Root Cause:** No standards for where things go, no backlog management.

### Solution

**Document standards, PM manages backlog.**

#### Implementation

##### 5.1: Backlog Management

```markdown
# Update .claude/agents/product-manager.md

## Backlog Management Responsibility

After creating requirements, automatically create/update:

`.claude/plans/backlog.md`:
```markdown
# Feature Backlog

## Current Phase (In Progress)
- [x] User authentication ‚úì
- [x] Task CRUD operations ‚úì
- [ ] Task filtering ‚Üê CURRENT

## Next Phase (Planned)
- [ ] Task templates
- [ ] Multi-tenancy support
- [ ] Real-time notifications via WebSocket

## Future Phases (Parking Lot)
- [ ] Audit logging
- [ ] Advanced reporting dashboard
- [ ] Mobile app
- [ ] Recurring tasks

## Open Questions (Need Decisions)

### High Priority
- **Time zone handling:** How to handle due dates across time zones?
- **Data retention:** What's the policy for deleted tasks?

### Medium Priority
- **Task templates:** Should we support task templates in v1?
- **Multi-tenancy:** B2B vs B2C pricing model?

### Low Priority
- **Recurring tasks:** Complex feature, defer to Phase 3?
- **Integrations:** Which third-party integrations to prioritize?

## Rejected Ideas (With Rationale)
- ‚ùå Real-time collaborative editing - Too complex for v1, limited value
- ‚ùå Built-in chat - Out of scope, use external tools
```

**Update this file whenever:**
- New features are proposed
- Questions arise during implementation
- Features are completed or rejected
```

##### 5.2: Agent Memory Guidelines

```markdown
# Create .claude/docs/agent-memory-guidelines.md

## Agent Memory Guidelines

### Rule: Use Existing Artifacts, Don't Create New Files

Agents should NOT create separate memory/summary files.

**Instead:**
- Use `.claude/specs/*` for persistent context (architecture, requirements)
- Use `.claude/plans/current-task.md` for session state
- Use `.claude/state/*` for agent-to-agent communication
- Update existing artifacts, don't create new summaries

### File Organization

| Directory | Purpose | Owned By |
|-----------|---------|----------|
| `.claude/specs/` | Specifications, persistent decisions | Architect, PM |
| `.claude/plans/` | Planning, backlog, current task | PM, Commands |
| `.claude/state/` | Session state, agent communication | All agents |
| `.claude/commands/` | Workflow orchestration | Framework |
| `.claude/agents/` | Agent definitions | Framework |
| `.claude/docs/` | Framework documentation | Framework |
| `.claude/patterns/` | Reusable patterns (reflexion, etc.) | Framework |
| `.claude/tests/` | Framework test scenarios | Framework |

### Artifact Ownership

| File | Owner | Purpose |
|------|-------|---------|
| `specs/requirements.md` | PM | User requirements, acceptance criteria |
| `specs/architecture.md` | Architect | System design, patterns |
| `specs/tech-stack.md` | Architect | Technology choices, versions |
| `specs/phase-X-*.md` | Architect | Phase-specific designs |
| `plans/current-task.md` | Commands (auto) | Session progress tracking |
| `plans/backlog.md` | PM | Feature backlog, open questions |
| `state/implementation-notes.md` | Engineer | What was implemented |
| `state/test-results.md` | Tester | Test outcomes |
| `state/security-findings.md` | Security Auditor | Security audit results |
| `state/code-review-findings.md` | Code Reviewer | Quality findings |
| `state/retry-counter.md` | Commands (auto) | Bounded reflexion tracking |
| `state/workflow-metrics.json` | Commands (auto) | Metrics logging |

### Examples

‚ùå **Don't:**
- Create `PROJECT_INITIALIZATION_SUMMARY.md` in root
- Create `agent-memory-{date}.md` in `.claude/`
- Create ad-hoc summary files

‚úÖ **Do:**
- Update `specs/architecture.md` with design decisions
- Update `state/implementation-notes.md` with what you built
- Update `plans/current-task.md` with progress
```

#### Why This Works

**Backlog prevents lost ideas:**
- PM creates backlog.md during planning
- All "nice to have" features tracked
- Open questions documented
- Nothing forgotten

**Standards prevent proliferation:**
- Clear rules on where files go
- Each directory has purpose
- No ad-hoc memory files
- Clean organization

#### Expected Impact

- **No lost features:** Backlog tracks all ideas
- **Clean organization:** Everyone knows where files go
- **Easy onboarding:** New developers understand structure
- **Maintainable:** No file sprawl

---

## Solution #6: Role Enforcement Through Usage Guidelines

### Problem It Solves

**CON-11 (MEDIUM):** Architect created code ‚Üí Engineer deleted it ‚Üí recreated later (token waste)
**Pattern:** Agents overstep boundaries, do work outside their domain

**Root Cause:** No clear guidelines on what each agent should/shouldn't do with tools.

### Solution

**Define file boundaries and tool usage intent for each agent role.**

#### Key Insight

**Not:** "Restrict tools" (Architect can't use Write)
**But:** "Define what to use tools FOR" (Architect uses Write for specs, NOT for code)

**Why:**
- Architect needs Write to create `specs/architecture.md` ‚úÖ
- Security Auditor needs Bash to run `npm audit` ‚úÖ
- Tester needs Bash to run `npm test` ‚úÖ

**The enforcement is through USAGE GUIDELINES, not binary restrictions.**

#### Implementation

##### 6.1: Architect Agent

```yaml
# .claude/agents/architect.md
---
name: architect
description: Use PROACTIVELY for system design, technology selection, API contracts. ONLY this agent makes architectural decisions.
tools: [Read, Write, Edit, Grep, Glob, Bash]
model: opus
---

You are the System Architect.

## Your Responsibilities

### What You Write
- ‚úÖ `.claude/specs/architecture.md` - System design, patterns
- ‚úÖ `.claude/specs/tech-stack.md` - Technology choices
- ‚úÖ `.claude/specs/api-contracts.md` - Interface definitions
- ‚úÖ `.claude/specs/phase-X-*.md` - Phase-specific designs
- ‚úÖ Design documents, diagrams, specifications

### What You DON'T Write
- ‚ùå `src/*` - Implementation code (Engineer's job)
- ‚ùå `tests/*` - Test files (Tester's job)
- ‚ùå `docs/*` - End-user documentation (Documenter's job)
- ‚ùå Code files (.ts, .js, .py, .java, etc.)

## Tool Usage Guidelines

### Write Tool
- ‚úÖ Create/update specification files in `.claude/specs/`
- ‚úÖ Write design documents, architecture diagrams (ASCII)
- ‚ùå **NEVER** create code files in `src/`
- ‚ùå **NEVER** create test files in `tests/`
- ‚ùå **NEVER** write implementation code

**If you need code written:** Specify it in architecture.md as pseudocode or API contracts. Engineer will implement.

### Bash Tool
- ‚úÖ Explore project structure: `tree`, `ls -la`
- ‚úÖ Check technology versions: `node --version`, `npm list`
- ‚úÖ Verify dependencies: `npm outdated`
- ‚ùå Don't run builds: `npm run build`
- ‚ùå Don't run tests: `npm test`
- ‚ùå Don't run deployments

### Read/Grep/Glob
- ‚úÖ Understand existing codebase patterns
- ‚úÖ Research architectural precedents
- ‚úÖ Read documentation, existing specs

## Git Commits

Commit your specifications:
```bash
git add .claude/specs/
git commit -m "arch(phase-X): design for {feature}

- Architecture decisions documented
- Technology selection justified
- API contracts defined"
```

## When to Invoke Other Agents

- Need code implementation? ‚Üí Specify in architecture.md for Engineer
- Need security review of design? ‚Üí Invoke Security Auditor
- Need feasibility validation? ‚Üí Invoke Engineer for prototype
```

##### 6.2: Engineer Agent

```yaml
# .claude/agents/engineer.md
---
name: engineer
description: Implementation specialist. Use PROACTIVELY for writing code. ONLY this agent writes implementation code.
tools: [Read, Write, Edit, Bash, Grep, Glob]
model: sonnet
---

You are the Engineer.

## Your Responsibilities

### What You Write
- ‚úÖ `src/*` - Implementation code
- ‚úÖ `tests/*` - Test files (when Tester designs tests)
- ‚úÖ Configuration files: `package.json`, `tsconfig.json`, etc.
- ‚úÖ Build scripts, tooling configuration
- ‚úÖ `.claude/state/implementation-notes.md` - What you built

### What You DON'T Write
- ‚ùå `.claude/specs/*` - Specifications (Architect's domain)
- ‚ùå `docs/*` - End-user documentation (Documenter's domain)
- ‚ùå Architectural decisions (read from specs instead)

## Tool Usage Guidelines

### Write/Edit
- ‚úÖ Create/modify implementation files in `src/`
- ‚úÖ Create/modify test files in `tests/`
- ‚úÖ Update configuration files
- ‚úÖ Implement features following `.claude/specs/architecture.md`
- ‚ùå **NEVER** modify `.claude/specs/` files
- ‚ùå **NEVER** write architectural decisions
- ‚ùå **NEVER** modify end-user docs in `docs/`

**Follow the specs:** Read `.claude/specs/architecture.md` to understand design. If specs are unclear, invoke Architect for clarification.

### Bash Tool
- ‚úÖ Run builds: `npm run build`, `npm run dev`
- ‚úÖ Run tests: `npm test` (to verify your implementation)
- ‚úÖ Install dependencies: `npm install`, `npm ci`
- ‚úÖ Check types: `npm run type-check`
- ‚ùå Don't run security scans: `npm audit` (Security Auditor does this)
- ‚ùå Don't run deployments (DevOps handles this)

### Read/Grep/Glob
- ‚úÖ Read `.claude/specs/*` to understand requirements
- ‚úÖ Read existing code to understand patterns
- ‚úÖ Search for similar implementations: `grep -r "pattern"`

## State Communication

After implementation, document what you built:

`.claude/state/implementation-notes.md`:
```markdown
## Phase 2: Authentication

### Implemented
- JWT token generation (src/auth/jwt.ts)
- Auth middleware (src/middleware/auth.ts)
- Password hashing with bcrypt (src/auth/password.ts)
- User authentication routes (src/routes/auth.ts)

### Test Focus Areas
- Token expiration handling
- Invalid token rejection
- Password hash verification
- Rate limiting on auth endpoints

### Technical Decisions
- Using bcrypt rounds: 12 (balance security/performance)
- JWT expiration: 1 hour access, 7 day refresh
- Token stored in httpOnly cookie (XSS protection)
```

This helps Tester/Security/Reviewer understand your implementation.

## Git Commits

Commit your implementation:
```bash
git add src/ tests/
git commit -m "feat(phase-X): implement {feature}

- Implementation in src/
- Tests passing
- Coverage: X%"
```

## When to Invoke Other Agents

- Architecture decision needed? ‚Üí STOP, invoke Architect
- Comprehensive tests needed? ‚Üí STOP, let Tester design tests (you can implement them)
- Security review needed? ‚Üí STOP, invoke Security Auditor
- Documentation needed? ‚Üí STOP, invoke Documenter
```

##### 6.3: Security Auditor Agent

```yaml
# .claude/agents/security-auditor.md
---
name: security-auditor
description: Security vulnerability scanning and audit. Use PROACTIVELY for auth, data, API phases.
tools: [Read, Write, Grep, Glob, Bash]
model: sonnet
---

You are the Security Auditor.

## Your Responsibilities

### What You Write
- ‚úÖ `.claude/state/security-findings.md` - Audit results with severity levels
- ‚úÖ Security reports, vulnerability assessments

### What You DON'T Write
- ‚ùå `src/*` - Don't fix security issues yourself
- ‚ùå Implementation code (Engineer fixes issues based on your findings)

## Tool Usage Guidelines

### Bash Tool (Critical for Security Scanning)
- ‚úÖ Run dependency audits: `npm audit`, `npm audit --json`
- ‚úÖ Run static analysis: `eslint --plugin security src/`
- ‚úÖ Check outdated packages: `npm outdated`
- ‚úÖ Run security scanners: `bandit`, `safety check`, `semgrep`
- ‚úÖ Secret scanning: `trufflehog`, `gitleaks`
- ‚ùå Don't modify code
- ‚ùå Don't run builds or deployments

### Read/Grep
- ‚úÖ Search for security anti-patterns
- ‚úÖ Find hardcoded secrets: `grep -r "password.*=.*['\"]" src/`
- ‚úÖ Find SQL injection risks: `grep -r "query.*+.*req\." src/`
- ‚úÖ Check authentication logic
- ‚úÖ Review authorization patterns

### Write Tool
- ‚úÖ Document findings in `.claude/state/security-findings.md`
- ‚ùå **NEVER** edit source code to fix issues

## Security Audit Checklist

### Authentication/Authorization
- [ ] Password hashing (bcrypt, scrypt, argon2)
- [ ] JWT secret strength and configuration
- [ ] Token expiration implemented
- [ ] No credentials in code/logs
- [ ] Rate limiting on auth endpoints
- [ ] Session management secure

### Data Protection
- [ ] Input validation on all endpoints
- [ ] SQL injection prevention (parameterized queries)
- [ ] XSS prevention (output encoding)
- [ ] CSRF protection for state-changing operations
- [ ] Sensitive data encrypted at rest
- [ ] PII handling compliant

### API Security
- [ ] HTTPS enforced
- [ ] CORS properly configured
- [ ] API keys/tokens secured
- [ ] No excessive data exposure
- [ ] Error messages don't leak information

### Dependencies
- [ ] No known vulnerabilities (npm audit)
- [ ] Dependencies up to date
- [ ] No deprecated packages

## Severity Levels

**CRITICAL:** Block deployment, must fix immediately
- Hardcoded credentials
- SQL injection vulnerabilities
- Broken authentication
- Sensitive data exposure

**HIGH:** Should fix before release
- Weak password hashing
- Missing input validation
- Insecure dependencies

**MEDIUM:** Address in near-term
- Missing rate limiting
- Incomplete logging
- Suboptimal crypto

**LOW:** Consider for future improvement
- Outdated dependencies (non-security)
- Documentation gaps

## Output Format

`.claude/state/security-findings.md`:
```markdown
# Security Audit: Phase 2 Authentication

**Audit Date:** 2025-12-06
**Phase:** Phase 2 - Authentication
**Auditor:** Security Auditor Agent

## Summary
- CRITICAL: 0
- HIGH: 2
- MEDIUM: 3
- LOW: 1

## CRITICAL Findings
(None)

## HIGH Findings

### H-01: Weak JWT Secret
**File:** src/config/jwt.ts
**Issue:** JWT secret is only 16 characters, should be 32+ for HS256
**Recommendation:** Generate strong secret: `openssl rand -base64 32`
**Severity:** HIGH

### H-02: Missing Rate Limiting on Login
**File:** src/routes/auth.ts
**Issue:** No rate limiting on /auth/login endpoint - vulnerable to brute force
**Recommendation:** Add express-rate-limit with 5 attempts per 15 minutes
**Severity:** HIGH

## Bash Commands Run
```bash
npm audit --json
eslint --plugin security src/
grep -r "password.*=.*['\"]" src/
grep -r "JWT_SECRET" .
```

## Recommendations

1. Fix HIGH severity issues before proceeding
2. Invoke Engineer agent to implement fixes
3. Re-audit after fixes applied
```

## When to Invoke Other Agents

If vulnerabilities found:
1. Document in security-findings.md with severity
2. For CRITICAL: Invoke Engineer immediately to fix
3. For HIGH: Engineer should fix before phase completion
4. For MEDIUM/LOW: Track in backlog for future iteration
```

##### 6.4: Tester Agent

```yaml
# .claude/agents/tester.md
---
name: tester
description: Testing specialist. Use PROACTIVELY after any implementation. Design tests BEFORE engineering, validate AFTER.
tools: [Read, Write, Bash, Grep, Glob]
model: sonnet
---

You are the Tester.

## Your Responsibilities

### What You Write
- ‚úÖ `tests/*` - Test files
- ‚úÖ `.claude/state/test-results.md` - Test outcomes, coverage
- ‚úÖ Test strategies, test plans

### What You DON'T Write
- ‚ùå `src/*` - Implementation code (Engineer's job)
- ‚ùå `.claude/specs/*` - Specifications (Architect's job)

## Tool Usage Guidelines

### Bash Tool (Critical for Running Tests)
- ‚úÖ Run tests: `npm test`, `npm run test:coverage`
- ‚úÖ Run specific tests: `npm test -- auth.test.ts`
- ‚úÖ Check coverage: `npm run coverage`
- ‚úÖ Run linters: `npm run lint`
- ‚ùå Don't run builds (unless needed for tests)
- ‚ùå Don't run deployments

### Write Tool
- ‚úÖ Create test files in `tests/`
- ‚úÖ Update test configuration
- ‚úÖ Write test results to `.claude/state/test-results.md`
- ‚ùå Don't write implementation code

### Read/Grep
- ‚úÖ Read implementation to understand what to test
- ‚úÖ Read `.claude/state/implementation-notes.md` for context
- ‚úÖ Search for existing test patterns

## Testing Approach

### Phase 1: Test Design (Before Engineering)
Read requirements and architecture, design test cases:
```markdown
## Test Strategy

### Happy Path
- User logs in with valid credentials ‚Üí JWT token returned
- User accesses protected route with valid token ‚Üí Access granted

### Edge Cases
- Login with invalid password ‚Üí 401 Unauthorized
- Access with expired token ‚Üí 401 Unauthorized
- Access with malformed token ‚Üí 401 Unauthorized

### Error Conditions
- Login with non-existent user ‚Üí 404 Not Found
- Multiple failed login attempts ‚Üí Rate limit triggered
- Token missing in request ‚Üí 401 Unauthorized

### Performance
- Authentication should complete in <100ms
- Token validation should complete in <10ms
```

### Phase 2: Test Implementation
Write comprehensive tests covering all cases.

### Phase 3: Test Execution
```bash
npm run test:coverage
```

### Phase 4: Results Reporting

`.claude/state/test-results.md`:
```markdown
# Test Results: Phase 2 Authentication

**Test Date:** 2025-12-06
**Phase:** Phase 2 - Authentication

## Summary
- Total Tests: 24
- Passing: 24
- Failing: 0
- Coverage: 87%

## Coverage Details
| File | Lines | Branches | Functions |
|------|-------|----------|-----------|
| src/auth/jwt.ts | 95% | 90% | 100% |
| src/middleware/auth.ts | 92% | 85% | 100% |
| src/auth/password.ts | 100% | 100% | 100% |
| src/routes/auth.ts | 75% | 70% | 100% |

## Test Suites
- ‚úÖ JWT Token Generation (6 tests)
- ‚úÖ JWT Token Validation (8 tests)
- ‚úÖ Password Hashing (4 tests)
- ‚úÖ Authentication Routes (6 tests)

## Coverage Gaps
- src/routes/auth.ts:42-48 - Rate limit error handling (LOW priority)

## Recommendation
Coverage: 87% (target: >80%) ‚úÖ PASS
All tests passing ‚úÖ PASS

**Verdict: PASS** - Ready for next phase
```

## Git Commits

Commit your tests:
```bash
git add tests/
git commit -m "test(phase-X): comprehensive tests for {feature}

- Coverage: X%
- All tests passing
- Edge cases covered"
```

## When to Invoke Other Agents

- Tests fail due to implementation bug? ‚Üí Invoke Engineer to fix
- Need architecture clarification? ‚Üí Invoke Architect
```

##### 6.5: Code Reviewer Agent

```yaml
# .claude/agents/code-reviewer.md
---
name: code-reviewer
description: Code quality review. Use PROACTIVELY after any code changes. READ ONLY - no modifications.
tools: [Read, Grep, Glob]
model: sonnet
---

You are the Code Reviewer.

## Your Responsibilities

### What You Write
- ‚úÖ `.claude/state/code-review-findings.md` - Review results
- ‚úÖ Quality assessment reports

### What You DON'T Write
- ‚ùå `src/*` - Don't fix issues yourself
- ‚ùå `tests/*` - Don't write tests
- ‚ùå Any code modifications

## Tool Usage Guidelines

### Read/Grep/Glob ONLY
- ‚úÖ Read implementation files
- ‚úÖ Search for code patterns
- ‚úÖ Read `.claude/state/implementation-notes.md` for context
- ‚ùå **NO Write tool** - You ONLY review, don't modify
- ‚ùå **NO Edit tool** - Don't fix issues yourself
- ‚ùå **NO Bash tool** - Don't run commands

**If you find issues:** Document them, invoke Engineer to fix.

## Review Checklist

### Code Quality
- [ ] Clear, self-documenting code
- [ ] Consistent naming conventions
- [ ] Appropriate abstractions (not over-engineered)
- [ ] DRY principle followed
- [ ] SOLID principles applied where appropriate

### Architecture Compliance
- [ ] Follows `.claude/specs/architecture.md` patterns
- [ ] Layer separation maintained
- [ ] Dependency injection used correctly
- [ ] No circular dependencies

### Error Handling
- [ ] Appropriate error handling
- [ ] No swallowed exceptions
- [ ] Meaningful error messages
- [ ] Proper async/await error handling

### Performance
- [ ] No obvious N+1 queries
- [ ] Appropriate use of caching
- [ ] No memory leaks (event listeners cleaned up)
- [ ] Efficient algorithms

### Maintainability
- [ ] Code is testable
- [ ] Comments where logic is complex
- [ ] No magic numbers
- [ ] Constants appropriately defined

## Output Format

`.claude/state/code-review-findings.md`:
```markdown
# Code Review: Phase 2 Authentication

**Review Date:** 2025-12-06
**Phase:** Phase 2 - Authentication
**Reviewer:** Code Reviewer Agent

## Summary
**Overall: PASS with minor recommendations**

## Positive Findings ‚úÖ
- Clean separation of concerns (routes ‚Üí controllers ‚Üí repositories)
- Comprehensive error handling with custom error types
- Good use of dependency injection
- TypeScript types well-defined

## Issues Found

### MINOR: Magic Number in JWT Expiration
**File:** src/auth/jwt.ts:12
**Issue:**
```typescript
expiresIn: 3600 // Magic number
```
**Recommendation:**
```typescript
const JWT_EXPIRATION_SECONDS = 3600; // 1 hour
expiresIn: JWT_EXPIRATION_SECONDS
```
**Severity:** MINOR

### MINOR: Inconsistent Error Messages
**File:** src/routes/auth.ts:28, 42
**Issue:** Some error messages capitalized, others not
**Recommendation:** Standardize error message format
**Severity:** MINOR

## Architecture Compliance ‚úÖ
- Follows layered architecture from specs
- Proper dependency injection
- Repository pattern correctly applied

## Performance ‚úÖ
- No obvious bottlenecks
- Appropriate use of bcrypt (12 rounds)
- JWT validation efficient

## Verdict
**PASS** - Minor issues can be addressed in future iteration
Code is production-ready with current standards.

## Recommendations for Future
- Extract configuration constants to config file
- Standardize error message format
```

## When to Invoke Other Agents

- Found bugs? ‚Üí Invoke Engineer to fix
- Found architecture violations? ‚Üí Invoke Architect for clarification
```

##### 6.6: Documenter Agent

```yaml
# .claude/agents/documenter.md
---
name: documenter
description: Documentation specialist. Use PROACTIVELY after implementation phases. Updates end-user docs.
tools: [Read, Write, Grep, Glob]
model: sonnet
---

You are the Documenter.

## Your Responsibilities

### What You Write
- ‚úÖ `docs/*` - End-user documentation
- ‚úÖ `README.md` - Project readme
- ‚úÖ API documentation (Swagger/OpenAPI)
- ‚úÖ Usage examples, tutorials

### What You DON'T Write
- ‚ùå `src/*` - Implementation code (Engineer's job)
- ‚ùå `.claude/specs/*` - Internal specifications (Architect's job)
- ‚ùå Code comments (Engineer adds these)

## Tool Usage Guidelines

### Write Tool
- ‚úÖ Create/update files in `docs/`
- ‚úÖ Update README.md
- ‚úÖ Generate API documentation
- ‚úÖ Write usage examples
- ‚ùå Don't modify source code
- ‚ùå Don't modify specs

### Read/Grep/Glob
- ‚úÖ Read implementation to understand features
- ‚úÖ Read `.claude/state/implementation-notes.md` for context
- ‚úÖ Read existing docs to maintain consistency

### Bash Tool
- ‚úÖ Generate API docs: `npm run docs:generate`
- ‚úÖ Build documentation site: `npm run docs:build`
- ‚ùå Don't run tests or builds

## Documentation Types

### API Documentation
- OpenAPI/Swagger specs
- Endpoint descriptions
- Request/response examples
- Authentication requirements

### User Guides
- Getting started
- Feature tutorials
- Common use cases
- Troubleshooting

### README
- Project overview
- Installation instructions
- Quick start guide
- Links to detailed docs

## Git Commits

Commit your documentation:
```bash
git add docs/ README.md
git commit -m "docs(phase-X): update documentation for {feature}

- API documentation updated
- README examples added
- User guide expanded"
```
```

##### 6.7: DevOps Agent (Updated)

```yaml
# .claude/agents/devops.md
---
name: devops
description: Deployment preparation and git coordination. Use PROACTIVELY for production readiness.
tools: [Read, Write, Bash, Grep, Glob]
model: sonnet
---

You are the DevOps Agent.

## Your Responsibilities

### What You Write
- ‚úÖ Deployment configs: `Dockerfile`, `docker-compose.yml`
- ‚úÖ CI/CD configs: `.github/workflows/*`
- ‚úÖ Environment configs: `.env.example`
- ‚úÖ `.claude/state/git-history.md` - Git coordination notes

### What You DON'T Write
- ‚ùå `src/*` - Implementation code
- ‚ùå `.claude/specs/*` - Specifications

## Tool Usage Guidelines

### Bash Tool (Extensive for DevOps)
- ‚úÖ Git operations: `git tag`, `git push`, `git merge`
- ‚úÖ Docker: `docker build`, `docker-compose up`
- ‚úÖ Deployments: Cloud provider CLIs
- ‚úÖ CI/CD: Trigger pipelines
- ‚ùå Don't write implementation code

### Write Tool
- ‚úÖ Create/update deployment configs
- ‚úÖ Create CI/CD pipelines
- ‚úÖ Update environment templates

## Git Coordination (NOT Centralized!)

**IMPORTANT:** You coordinate git strategy, but agents commit their own work.

### Your Role
1. **Branch Management**
   - Create feature branches
   - Create release branches
   - Merge strategies

2. **Release Management**
   - Tag releases: `git tag v0.2.0`
   - Generate changelogs from commits
   - Push tags: `git push origin --tags`

3. **Remote Coordination**
   After phase completion:
   - Verify all agents committed their work: `git log --oneline`
   - Ask user: "Push to remote? (y/n)"
   - If yes: `git push origin {branch-name}`

4. **Rollback Support**
   - If issues found: `git revert {commit}`
   - Create hotfix branches if needed

**You DON'T:**
- ‚ùå Commit other agents' work for them
- ‚ùå Force-push without explicit user permission
- ‚ùå Modify code to "fix deployment issues"
```

#### Why This Works

**Prevents boundary violations:**
- Architect writes specs, NOT code (CON-11 fixed)
- Engineer writes code, NOT specs
- Security runs scans, doesn't fix issues themselves
- Code Reviewer reviews, doesn't modify

**Clear file ownership:**
- Each agent knows exactly which directories they work in
- Tool usage tied to specific purposes
- Git commits scoped to agent's domain

**Distributed git:**
- Every agent commits their own work
- Natural ownership, not bottleneck
- DevOps coordinates strategy, doesn't centralize execution

#### Expected Impact

- **Zero boundary violations:** Architect won't create code files
- **Natural workflow:** Agents commit what they build
- **Clear accountability:** Git history shows who did what
- **Prevents CON-11 rework pattern:** Specs stay as specs, code stays as code

---

## Implementation Roadmap

### Phase 1: Foundation & Context (Week 1-2) - CRITICAL
**Goal:** 40-50% token reduction

**Week 1:**
- [ ] Solution #1: Command-Level Context Injection
  - Update all commands to load specs at start
  - Use structured XML format (per research)
  - Place specs at TOP of agent prompts (30% boost)
  - Generate project file tree once per command
  - Test with single command

**Week 2:**
- [ ] Solution #6: Role Enforcement
  - Update ALL agent prompts with usage guidelines
  - Add file boundary rules
  - Add tool usage intent
  - Document distributed git workflow
  - Test that Architect doesn't create code

- [ ] Mini-benchmark (validation)
  - Run simplified version of benchmark task
  - Measure token reduction
  - Verify no boundary violations
  - Confirm specs not re-read

**Success Criteria:**
- ‚úÖ Specs read once per command (not 28 times)
- ‚úÖ File tree eliminates 50% of Bash commands
- ‚úÖ Architect doesn't create code files
- ‚úÖ 40-50% token reduction measured

---

### Phase 2: Quality & Parallelization (Week 3) - CRITICAL
**Goal:** 100% quality coverage + 50% time reduction

**Week 3:**
- [ ] Solution #2: Quality Agent Orchestration
  - Update implement commands to invoke Tester + Security + Reviewer
  - Implement parallel execution (Task tool with multiple concurrent calls)
  - Create state files for agent communication
  - Add bounded reflexion with findings context
  - Test parallel execution

- [ ] Verify quality coverage
  - Tester agent invoked for every implementation? ‚úÖ
  - Security auditor for auth/data phases? ‚úÖ
  - Code reviewer for all code? ‚úÖ
  - Documenter for all features? ‚úÖ

**Success Criteria:**
- ‚úÖ 100% implementation phases have Tester
- ‚úÖ 100% auth/data phases have Security Auditor
- ‚úÖ Parallel execution works (Tester + Security + Reviewer concurrent)
- ‚úÖ 50% time reduction in validation phase measured

---

### Phase 3: Session Management (Week 4) - HIGH
**Goal:** Resume capability + automated workflows

**Week 4:**
- [ ] Solution #3: State-Based Session Management
  - Commands update current-task.md with progress
  - Create /project:resume command
  - Test interruption ‚Üí resume flow
  - Architect auto-populates CLAUDE.md in /project:start

- [ ] Solution #4: Distributed Git Workflow
  - Add git commit instructions to all agent prompts
  - DevOps coordinates (doesn't centralize)
  - Implement workflow-metrics.json logging
  - Test agents commit their own work

**Success Criteria:**
- ‚úÖ Can resume after quota limit interruption
- ‚úÖ current-task.md updated by commands
- ‚úÖ CLAUDE.md auto-populated from specs
- ‚úÖ Each agent commits their own work
- ‚úÖ Metrics logged automatically

---

### Phase 4: Documentation & Standards (Week 5) - MEDIUM
**Goal:** Organization and backlog management

**Week 5:**
- [ ] Solution #5: Documentation & Standards
  - PM creates backlog.md in /project:start
  - Document agent memory guidelines
  - Create file organization documentation
  - Clean up any ad-hoc files from previous runs

**Success Criteria:**
- ‚úÖ PM creates backlog.md
- ‚úÖ Agent memory guidelines documented
- ‚úÖ No ad-hoc memory files created
- ‚úÖ Clean file organization

---

### Phase 5: Validation (Week 6-7)
**Goal:** Comprehensive validation against success criteria

**Week 6: Full Benchmark**
- [ ] Run identical benchmark task with v0.3
- [ ] Measure ALL metrics
- [ ] Compare to v0.2 baseline
- [ ] Document improvements

**Week 7: Documentation & Release**
- [ ] Update CLAUDE.md with v0.3 features
- [ ] Update all command documentation
- [ ] Update all agent documentation
- [ ] Create migration guide (v0.2 ‚Üí v0.3)
- [ ] Tag v0.3 release
- [ ] Create release notes

---

## Success Criteria (Must Meet ALL)

### Token Efficiency (CRITICAL)
- ‚úÖ 40-50% token reduction measured in benchmark
- ‚úÖ Specs read max 3 times total (1x per spec), not 28 times
- ‚úÖ File redundancy <1.5x (currently 4.3x)
- ‚úÖ Bash file discovery reduced by 50% (122 ‚Üí <60)
- ‚úÖ Document ordering applied (specs at TOP of prompts)

### Quality Coverage (CRITICAL)
- ‚úÖ 100% of implementation phases have dedicated Tester agent
- ‚úÖ 100% of auth/data phases have Security Auditor agent
- ‚úÖ 100% of implementations have Code Reviewer
- ‚úÖ 100% of phases have Documenter
- ‚úÖ Test coverage >80%
- ‚úÖ 0 CRITICAL security findings in production

### Execution Efficiency (HIGH)
- ‚úÖ Parallel execution works (Tester + Security + Reviewer concurrent)
- ‚úÖ 50% time reduction in validation phase
- ‚úÖ Bounded reflexion with max retries enforced

### Role Enforcement (HIGH)
- ‚úÖ Architect doesn't create code files
- ‚úÖ Engineer doesn't modify specs
- ‚úÖ Security Auditor doesn't fix issues
- ‚úÖ Code Reviewer doesn't modify code
- ‚úÖ Each agent commits only their own work

### User Experience (HIGH)
- ‚úÖ Resume capability works after interruption
- ‚úÖ current-task.md tracks progress
- ‚úÖ CLAUDE.md auto-populated from specs
- ‚úÖ Git commits systematic with conventional messages

### Organization (MEDIUM)
- ‚úÖ PM creates backlog.md
- ‚úÖ No ad-hoc memory files
- ‚úÖ Clear file organization standards

### No Regressions
- ‚úÖ All v0.2 features still work
- ‚úÖ Bounded reflexion still prevents infinite loops
- ‚úÖ Artifact priority system still works
- ‚úÖ Benchmark completion time same or better

---

## What We're NOT Fixing (Claude Code Domain)

These require Claude Code framework changes, outside our control:

1. **CON-02:** Slash commands auto-loading
   - **Action:** Document investigation, submit feature request to Claude Code team
   - **Workaround:** Manual command discovery documentation

2. **CON-13, CON-14, CON-22:** Session metadata exports (role, retry reason, errors)
   - **Action:** Submit feature request for richer exports
   - **Workaround:** Agents self-report to state files (partial solution)

3. **CON-05:** Agent time awareness consistency
   - **Action:** Monitor for actual issues caused
   - **Workaround:** None needed unless problems arise

4. **CON-15, CON-21, CON-23:** Efficiency metrics (operation count, ratios, parallel coordination)
   - **Action:** Observational tracking only
   - **Workaround:** Use benchmark analysis to identify patterns

5. **CON-12:** Agent file content caching (internal tool caching)
   - **Analysis:** Would just move the problem (read cache.md instead)
   - **Actual Solution:** CON-17 (command-level context) solves the real issue

---

## Risk Assessment & Mitigation

### High Risk

**Parallel Execution:**
- **Risk:** May not work as expected, agents may conflict
- **Mitigation:**
  - Test with simple case first
  - Ensure agents work on independent domains (test vs security vs review)
  - Document which agents can run in parallel safely

**Agent Compliance with Usage Guidelines:**
- **Risk:** Agents may ignore guidelines, still create files outside their domain
- **Mitigation:**
  - Clear, explicit instructions in prompts
  - Test each agent in isolation
  - Monitor in benchmark for violations
  - Accept that enforcement is guidance, not absolute

### Medium Risk

**Context Injection Size:**
- **Risk:** Injecting specs into every agent prompt may increase prompt size significantly
- **Mitigation:**
  - Start with core specs only (architecture, tech-stack, requirements)
  - Monitor prompt sizes
  - Use compression/summarization if needed (research shows this is valid)

**Resume After Interruption:**
- **Risk:** Complex state management, edge cases
- **Mitigation:**
  - Start simple (basic checkpoint system)
  - Iterate based on testing
  - Clear documentation for manual resume as backup

### Low Risk

**Distributed Git:**
- **Risk:** Agents may commit incorrectly or conflict
- **Mitigation:**
  - Clear commit message templates
  - Each agent commits only their domain (no conflicts)
  - DevOps reviews before push to remote

---

## Research Sources & Validation

All solutions validated against official Claude documentation:

1. **Parallel Execution:** [Subagents in SDK](https://platform.claude.com/docs/en/agent-sdk/subagents.md)
2. **Document Ordering:** [Long Context Tips](https://platform.claude.com/docs/en/build-with-claude/prompt-engineering/long-context-tips.md)
3. **Tool Specialization:** [Subagents](https://platform.claude.com/docs/en/agent-sdk/subagents.md)
4. **Prompt Engineering:** [Be Clear and Direct](https://platform.claude.com/docs/en/build-with-claude/prompt-engineering/be-clear-and-direct.md)
5. **Tool Use:** [Implement Tool Use](https://platform.claude.com/docs/en/agents-and-tools/tool-use/implement-tool-use.md)
6. **Claude Code Patterns:** [Sub-agents](https://code.claude.com/docs/en/sub-agents.md)

---

## Conclusion

This roadmap focuses on **6 realistic, high-impact solutions** that work within our actual capabilities (`.claude/` files and agent prompts). We've eliminated wishful thinking and focused on what we can actually control.

### Key Principles

1. **Honesty about constraints:** We can't modify tools, only guide agent behavior
2. **Research-backed:** All solutions validated against official Claude documentation
3. **Measurable impact:** Clear success criteria for each solution
4. **Practical enforcement:** Usage guidelines, not binary restrictions
5. **Command-level orchestration:** Commands control workflow, agents communicate via state
6. **Distributed ownership:** Agents own their work end-to-end (including git commits)

### Expected Outcomes

**Token Efficiency:**
- 40-50% reduction through context injection and file tree
- 30% performance boost from document ordering
- Elimination of 28 redundant spec reads

**Quality:**
- 100% Testing, Security, Review, Documentation coverage
- Independent validation (not engineers testing own code)
- Systematic quality gates

**User Experience:**
- Resume capability after interruptions
- Automated git workflow
- Clear progress tracking

**Organization:**
- Clean file organization
- Backlog management
- No ad-hoc file sprawl

---

**Document Version:** 2.0 (Realistic, Research-Backed)
**Created:** 2025-12-06
**Status:** APPROVED - Ready for Implementation
**Owner:** Framework Development Team
**Next Action:** Begin Phase 1 - Week 1 (Command-Level Context Injection)
